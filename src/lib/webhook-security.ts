/**
 * Webhook Security - Anti-rejeu et idempotence
 * 
 * CRITIQUE: √âviter le double traitement d'√©v√©nements Stripe
 * Protection contre attaques replay et retry storms
 */

import { db } from './db'
import { createHash } from 'crypto'

interface WebhookEventRecord {
  id: string
  eventId: string
  eventType: string
  processed: boolean
  processedAt: Date | null
  payloadHash: string | null
  retryCount: number
  lastError: string | null
  createdAt: Date
}

/**
 * V√©rifie si un √©v√©nement a d√©j√† √©t√© trait√© (idempotence)
 * Enregistre l'√©v√©nement pour √©viter le rejeu
 * 
 * S√âCURIT√â: Utilise une approche "INSERT OR CONFLICT" pour √©viter les race conditions
 * En cas de workers parall√®les, un seul r√©ussira le CREATE, l'autre r√©cup√®rera l'existant
 */
export async function ensureEventIdempotence(
  eventId: string,
  eventType: string,
  payload?: any
): Promise<{ shouldProcess: boolean; isRetry: boolean; eventRecord?: WebhookEventRecord }> {
  try {
    // Calculer hash du payload pour v√©rification d'int√©grit√©
    const payloadHash = payload ? createPayloadHash(payload) : null

    // APPROCHE S√âCURIS√âE: Tenter de cr√©er d'abord (atomic operation)
    // En cas de conflit (event d√©j√† existant), r√©cup√©rer l'existant
    try {
      const eventRecord = await db.webhookEvent.create({
        data: {
          eventId,
          eventType,
          processed: false,
          payloadHash,
          retryCount: 0
        }
      })
      
      console.log('üìù New webhook event registered:', {
        eventId,
        eventType,
        recordId: eventRecord.id
      })
      
      return { 
        shouldProcess: true, 
        isRetry: false, 
        eventRecord 
      }
      
    } catch (createError: any) {
      // CONFLIT D√âTECT√â: L'eventId existe d√©j√† (contrainte unique)
      // Cela peut arriver avec des workers parall√®les ou des retries Stripe
      
      if (createError?.code === 'P2002' || createError?.message?.includes('Unique constraint')) {
        console.log('üîç Event conflict detected, fetching existing record:', { eventId })
        
        // R√©cup√©rer l'enregistrement existant
        const existingRecord = await db.webhookEvent.findUnique({
          where: { eventId }
        })
        
        if (!existingRecord) {
          // Race condition √©trange - l'enregistrement a disparu entre temps
          console.error('‚ö†Ô∏è Race condition: record disappeared after conflict!')
          return { 
            shouldProcess: true, 
            isRetry: false 
          }
        }
        
        console.log('Existing webhook event found:', {
          eventId,
          eventType,
          processed: existingRecord.processed,
          retryCount: existingRecord.retryCount,
          processedAt: existingRecord.processedAt,
        })

        if (existingRecord.processed) {
          // D√©j√† trait√© avec succ√®s - ignorer (idempotence)
          console.log('‚úÖ Event already processed successfully - ignoring replay/duplicate')
          return { 
            shouldProcess: false, 
            isRetry: true, 
            eventRecord: existingRecord 
          }
        } else {
          // √âchec pr√©c√©dent ou traitement en cours - autoriser retry
          console.log('üîÑ Retrying previously failed/pending event')
          
          const updatedRecord = await db.webhookEvent.update({
            where: { eventId },
            data: { 
              retryCount: { increment: 1 },
              payloadHash: payloadHash || existingRecord.payloadHash
            }
          })
          
          return { 
            shouldProcess: true, 
            isRetry: true, 
            eventRecord: updatedRecord 
          }
        }
        
      } else {
        // Erreur diff√©rente (probl√®me DB, network, etc.)
        console.error('Unexpected database error during event creation:', createError)
        throw createError
      }
    }

  } catch (error) {
    console.error('Critical error in event idempotence check:', error)
    
    // En cas d'erreur critique, √™tre conservateur et traiter l'√©v√©nement
    // (mieux traiter en doublon qu'ignorer un vrai √©v√©nement)
    console.warn('‚ö†Ô∏è  Idempotence check failed - processing event (conservative approach)')
    
    return { 
      shouldProcess: true, 
      isRetry: false 
    }
  }
}

/**
 * Marque un √©v√©nement comme trait√© avec succ√®s
 */
export async function markEventProcessed(
  eventId: string,
  success: boolean = true,
  error?: string
): Promise<void> {
  try {
    await db.webhookEvent.update({
      where: { eventId },
      data: {
        processed: success,
        processedAt: success ? new Date() : null,
        lastError: error || null
      }
    })
    
    console.log(`Event marked as ${success ? 'processed' : 'failed'}:`, {
      eventId,
      success,
      error: error || null
    })
    
  } catch (updateError) {
    console.error('Failed to update event status:', {
      eventId,
      success,
      error: updateError
    })
  }
}

/**
 * Cr√©e un hash SHA256 du payload pour v√©rification d'int√©grit√©
 */
function createPayloadHash(payload: any): string {
  return createHash('sha256')
    .update(JSON.stringify(payload))
    .digest('hex')
}

/**
 * Nettoie les anciens √©v√©nements (maintenance)
 * √Ä ex√©cuter p√©riodiquement via cron ou t√¢che
 */
export async function cleanupOldWebhookEvents(olderThanDays: number = 30): Promise<number> {
  try {
    const cutoffDate = new Date()
    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays)
    
    const result = await db.webhookEvent.deleteMany({
      where: {
        createdAt: {
          lt: cutoffDate
        },
        processed: true // Seulement les √©v√©nements trait√©s avec succ√®s
      }
    })
    
    console.log(`Cleaned up ${result.count} old webhook events older than ${olderThanDays} days`)
    return result.count
    
  } catch (error) {
    console.error('Error cleaning up webhook events:', error)
    return 0
  }
}

/**
 * Obtient les statistiques des √©v√©nements webhook
 */
export async function getWebhookStats(): Promise<{
  total: number
  processed: number
  failed: number
  pending: number
  avgRetryCount: number
}> {
  try {
    const [total, processed, failed] = await Promise.all([
      db.webhookEvent.count(),
      db.webhookEvent.count({ where: { processed: true } }),
      db.webhookEvent.count({ 
        where: { 
          processed: false, 
          retryCount: { gt: 0 } 
        } 
      })
    ])
    
    const pending = total - processed - failed
    
    const avgRetryCountResult = await db.webhookEvent.aggregate({
      _avg: { retryCount: true }
    })
    
    const avgRetryCount = avgRetryCountResult._avg.retryCount || 0
    
    return {
      total,
      processed,
      failed,
      pending,
      avgRetryCount: Number(avgRetryCount.toFixed(2))
    }
    
  } catch (error) {
    console.error('Error getting webhook stats:', error)
    return {
      total: 0,
      processed: 0,
      failed: 0,
      pending: 0,
      avgRetryCount: 0
    }
  }
}
